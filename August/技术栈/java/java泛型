
1、 
 	泛型，即“参数化类型”。

 	一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。
 	那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

	泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。



一个栗子	

	List arrayList = new ArrayList();
	arrayList.add("aaaa");
	arrayList.add(100);

	for(int i = 0; i< arrayList.size();i++){

   		String item = (String)arrayList.get(i);
    	Log.d("泛型测试","item = " + item);
	}

	毫无疑问，程序的运行结果会以崩溃结束：


	ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。


	我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。
		List<String> arrayList = new ArrayList<String>();
		...
		//arrayList.add(100); 在编译阶段，编译器就会报错


	Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。	

泛型的使用

		泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法




	定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。	


	泛型的类型参数只能是类类型，不能是简单类型。